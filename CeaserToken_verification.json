{
    "language": "Solidity",
    "settings": {
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode.object",
                    "evm.sourceMap"
                ]
            }
        }
    },
    "sources": {
        "CeaserToken.sol": {
            "content": "\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * Tokenomics:\n * \n * Liquidity        0%\n * Redistribution   1.69%\n * Burn             0.31%\n * Charity          0%\n * Marketing        0%\n */\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n}\n\nabstract contract Tokenomics {\n    using Address for address;\n\n    string internal constant NAME = \"Ceaser\";\n    string internal constant SYMBOL = \"CSR\";\n    uint8 internal constant DECIMALS = 9;\n\n    uint256 internal constant TOTAL_SUPPLY = 110000000 * 10**uint256(DECIMALS);\n\n    uint256 internal constant FEES_DIVISOR = 10**4;\n    uint256 internal constant REDISTRIBUTION_FEE = 169; // 1.69%\n    uint256 internal constant BURN_FEE = 31; // 0.31%\n\n    address internal constant BURN_ADDRESS = address(0);\n\n    uint256 internal _reflectedSupply = (TOTAL_SUPPLY * 2**128 - 1);\n\n    mapping(address => uint256) internal _reflectedBalances;\n    mapping(address => uint256) internal _balances;\n    mapping(address => mapping(address => uint256)) internal _allowances;\n    mapping(address => bool) internal _isExcludedFromFee;\n    mapping(address => bool) internal _isExcludedFromRewards;\n    address[] internal _excluded;\n\n    function _getValues(uint256 tAmount) internal view returns (uint256, uint256, uint256, uint256, uint256) {\n        uint256 tFee = tAmount * REDISTRIBUTION_FEE / FEES_DIVISOR;\n        uint256 tBurn = tAmount * BURN_FEE / FEES_DIVISOR;\n        uint256 tTransferAmount = tAmount - tFee - tBurn;\n        uint256 currentRate = _getRate();\n        uint256 rAmount = tAmount * currentRate;\n        uint256 rFee = tFee * currentRate;\n        uint256 rBurn = tBurn * currentRate;\n        uint256 rTransferAmount = rAmount - rFee - rBurn;\n        return (rAmount, rTransferAmount, tFee, tBurn, tTransferAmount);\n    }\n\n    function _getRate() internal view returns (uint256) {\n        (uint256 rSupply, uint256 tSupply) = _getCurrentSupply();\n        return rSupply / tSupply;\n    }\n\n    function _getCurrentSupply() internal view returns (uint256, uint256) {\n        uint256 rSupply = _reflectedSupply;\n        uint256 tSupply = TOTAL_SUPPLY;\n        for (uint256 i = 0; i < _excluded.length; i++) {\n            if (_reflectedBalances[_excluded[i]] > rSupply || _balances[_excluded[i]] > tSupply) return (_reflectedSupply, TOTAL_SUPPLY);\n            rSupply -= _reflectedBalances[_excluded[i]];\n            tSupply -= _balances[_excluded[i]];\n        }\n        if (rSupply < _reflectedSupply / TOTAL_SUPPLY) return (_reflectedSupply, TOTAL_SUPPLY);\n        return (rSupply, tSupply);\n    }\n\n    function _redistribute(uint256 tFee, uint256 currentRate) internal {\n        uint256 rFee = tFee * currentRate;\n        _reflectedSupply -= rFee;\n    }\n\n    function _burnTokens(uint256 tBurn, uint256 currentRate) internal {\n        uint256 rBurn = tBurn * currentRate;\n        _reflectedBalances[BURN_ADDRESS] += rBurn;\n        if (_isExcludedFromRewards[BURN_ADDRESS]) {\n            _balances[BURN_ADDRESS] += tBurn;\n        }\n    }\n}\n\ncontract CeaserToken is IERC20, IERC20Metadata, Tokenomics, Ownable {\n\n    constructor() {\n        _reflectedBalances[msg.sender] = _reflectedSupply;\n        emit Transfer(address(0), msg.sender, TOTAL_SUPPLY);\n    }\n\n    function name() public view virtual override returns (string memory) {\n        return NAME;\n    }\n\n    function symbol() public view virtual override returns (string memory) {\n        return SYMBOL;\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return DECIMALS;\n    }\n\n    function totalSupply() public view virtual override returns (uint256) {\n        return TOTAL_SUPPLY;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        if (_isExcludedFromRewards[account]) return _balances[account];\n        return tokenFromReflection(_reflectedBalances[account]);\n    }\n\n    function tokenFromReflection(uint256 rAmount) internal view returns (uint256) {\n        uint256 currentRate = _getRate();\n        return rAmount / currentRate;\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        require(currentAllowance >= amount, \"CeaserToken: transfer amount exceeds allowance\");\n        _approve(sender, msg.sender, currentAllowance - amount);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"CeaserToken: transfer from the zero address\");\n        require(recipient != address(0), \"CeaserToken: transfer to the zero address\");\n\n        uint256 senderBalance = _reflectedBalances[sender];\n        require(senderBalance >= amount, \"CeaserToken: transfer amount exceeds balance\");\n\n        uint256 currentRate = _getRate();\n        (uint256 rAmount, uint256 rTransferAmount, uint256 tFee, uint256 tBurn, uint256 tTransferAmount) = _getValues(amount);\n\n        _reflectedBalances[sender] -= rAmount;\n        _reflectedBalances[recipient] += rTransferAmount;\n\n        if (_isExcludedFromRewards[sender]) _balances[sender] -= amount;\n        if (_isExcludedFromRewards[recipient]) _balances[recipient] += tTransferAmount;\n\n        _redistribute(tFee, currentRate);\n        _burnTokens(tBurn, currentRate);\n\n        emit Transfer(sender, recipient, tTransferAmount);\n        emit Transfer(sender, BURN_ADDRESS, tBurn);\n    }\n\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"CeaserToken: approve from the zero address\");\n        require(spender != address(0), \"CeaserToken: approve to the zero address\");\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n}\n"
        }
    }
}